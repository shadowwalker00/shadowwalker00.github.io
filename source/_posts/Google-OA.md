---
title: Google OA
date: 2018-11-16 18:09:15
tags: 
categories: 面试
---

<blockquote class="blockquote-center">每临大事，必有静气。Always keeping Poker Face.</blockquote>

11月12日收到OA的链接，让11月19日之前做完。一共两道题，两道题都在一亩三分地上看到过。第一道是给一颗树，找出与每个节点距离为N的祖先。第二道题是Store-house问题。

<!-- more --> 

## 1. 距离N的祖先

**题目描述：**输入一个整型的vector，以及一个距离D，求与每个节点的距离为D的祖先。这个整型数组的下标表示节点的index，val表示该节点的父节点的下标。其中，根节点因为没有父节点，因此其父节点的下标是-1。

举个例子，如果输入是$[-1,0,0,2,3]$，那么这棵树应该描述为下图所示的样子。

这个例的最终输出应该是$[-1,-1,0,1,2]$。

**我的解法：**遍历树中的每一个节点，从该节点向上搜索，如果在搜索过程中（在遇到-1之前），遇到了D个节点，那么最后一个遍历到的节点则是距离初始节点距离为D的祖先。如果在向上搜索的过程中，未到达D个节点便遇到了-1，那么该节点没有距离为D的祖先。

## 2. Store-house

**题目描述：**输入两个数组Stores和houses，每个元素都表示了store或者house在一维空间中的坐标。要求输出距离每一个house最近的store的坐标。

举个例子，store数组是$[1,16,5,11,20]$，house数组是$[5,10,17]$。那么最终的输出应该是$[5,11,16]$，分别表示距离每一个house最近的store的坐标。

**我的解法：**首先对store进行排序，然后对每一个house坐标在排序后的store数组中进行二叉搜索，如果在store中搜索到了这个解，那么这个store的坐标就是距离house最近的store；而如果搜索不到，二叉搜索最终终止循环的两个索引L和R构成的两个相邻数当中，与当前house坐标差最小的便是距离最近的store，如果差值相等，那么就取L指向的store。